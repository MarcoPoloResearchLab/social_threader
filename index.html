<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-55NSC8PNTB"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-55NSC8PNTB');
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="description" content="Threader lets you break long text into manageable chunks for social media. Perfect for splitting text while preserving punctuation as part of the preceding word." />
    <meta name="keywords" content="text chunker, thread splitter, social media text, sentence chunking, Twitter threads, Bluesky posts, content tool, copywriting tool" />
    <title>Social Threader</title>
    <style>
        /* 1) Global reset & layout for sticky footer */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: Arial, sans-serif;
            background-color: #fff;
            color: #000;
        }

        .container {
            flex: 1;
            display: flex;
            width: 100%;
        }

        /* Utility classes */
        .mb-20 {
            margin-bottom: 20px;
        }

        /* 2) Split layout: left-pane & right-pane */
        .left-pane {
            flex: 2;
            padding: 20px;
            border-right: 1px solid #ccc;
            display: flex;
            flex-direction: column;
        }

        .right-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        /* Left pane styles */
        .left-pane textarea {
            flex: 1;
            width: 100%;
            padding: 10px;
            font-size: 14px;
            resize: none;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f9f9f9;
            color: #212529;
            transition: font-size 0.2s ease;
        }

        .inputStats {
            margin-top: 10px;
            font-size: 12px;
            color: #555;
        }

        .error {
            color: red;
            font-size: 12px;
            margin-top: 5px;
        }

        /* Right pane & controls */
        .upper-right-pane {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        /* Now let the lower-right-pane flex to fill remaining space */
        .lower-right-pane {
            flex: 1;
            overflow-y: auto;
            padding-top: 10px;
            position: relative;
        }

        .button-group,
        .custom-control {
            width: 90%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Reserve 2px border to avoid shifting when active */
        button {
            background-color: #007bff;
            color: #fff;
            padding: 10px;
            font-size: 14px;
            border: 2px solid transparent;
            border-radius: 4px;
            height: 40px;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        .button-group button {
            width: 100%;
        }

        .custom-control {
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
        }

        .custom-control button {
            margin-right: 10px;
            flex: 1;
        }

        .custom-control input {
            width: 80px;
            height: 40px;
            font-size: 14px;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
        }

        .toggle-sentence-break {
            width: 90%;
            max-width: 600px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
            justify-content: space-between;
        }

        .toggle-sentence-break .toggle-options {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .toggle-sentence-break label {
            font-size: 14px;
            user-select: none;
        }

        /* Output pane */
        .threadWrapper {
            position: relative;
            margin-bottom: 20px;
        }

        .threadWrapper::before {
            content: "";
            position: absolute;
            top: 0;
            left: 20px;
            width: 2px;
            height: 100%;
            background-color: #ccc;
        }

        .chunkContainer {
            position: relative;
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
            padding-left: 40px;
        }

        .chunkContainer::before {
            content: "";
            position: absolute;
            top: 0;
            left: 11px;
            width: 18px;
            height: 18px;
            background-color: #fff;
            border: 2px solid #007bff;
            border-radius: 50%;
            z-index: 1;
        }

        .chunkContainer textarea {
            width: 100%;
            resize: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f9f9f9;
            color: #212529;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 40px;
            overflow-y: hidden;
            transition: height 0.1s ease-out;
        }

        .chunkInfo {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 5px;
        }

        .stats {
            font-size: 12px;
            color: #555;
        }

        .copyButton {
            background-color: #28a745;
        }

        .copyButton:hover {
            background-color: #218838;
        }

        .copyButton.success {
            background-color: #28a745;
            cursor: default;
        }

        .chunkContainer.copied::before {
            content: attr(data-copied-order);
            background-color: #28a745;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }

        /* Responsive layout */
        @media (max-width: 800px) {
            .container {
                flex-direction: column;
            }

            .left-pane {
                border-right: none;
                border-bottom: 1px solid #ccc;
                padding-bottom: 20px;
                order: 0;
            }

            .right-pane {
                width: 100%;
                height: auto;
            }

            .upper-right-pane {
                order: 1;
                width: 100%;
            }

            .lower-right-pane {
                order: 2;
                width: 100%;
                overflow-y: auto;
            }

            .threadWrapper::before {
                left: 15px;
            }

            .chunkContainer {
                padding-left: 35px;
            }

            .chunkContainer::before {
                left: 6px;
            }
        }

        /* Footer styling */
        footer {
            text-align: center;
            padding: 20px;
            border-top: 1px solid #ccc;
        }

        /* Active button state – uses the same border width to avoid layout shifts */
        button.active {
            background-color: #004085;
            border-color: #002752;
            font-weight: bold;
            box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.2);
        }

        /* Special handling for copy button - don't show pressed state */
        .copyButton.active {
            background-color: #28a745;
            border: none;
            box-shadow: none;
            font-weight: normal;
        }
    </style>
</head>

<body>
<div class="container">
    <!-- LEFT PANE -->
    <div class="left-pane">
        <h2>Social Threader</h2>
        <p class="mb-20">
            With Social Threader, you can split your text into smaller chunks
            ideal for Twitter/X, Bluesky, Threads, Mastodon, or any platform that
            limits character count.
        </p>
        <p class="mb-20">
            Easily create threads, track word counts, and copy each chunk with a
            single click.
        </p>
        <textarea id="sourceText" spellcheck="true" placeholder="Enter text here..." rows="10"></textarea>
        <div id="inputStats" class="inputStats"></div>
        <div id="inputError" class="error"></div>
    </div>

    <!-- RIGHT PANE -->
    <div class="right-pane">
        <div class="upper-right-pane">
            <!-- Preset chunk sizes -->
            <div class="button-group">
                <button data-length="500">Break into Threads/Mastodon (500)</button>
                <button data-length="300">Break into Bluesky (300)</button>
                <button data-length="280">Break into Twitter/X (280)</button>
            </div>
            <!-- Custom chunk size -->
            <div class="custom-control">
                <button id="customButton">Break with Custom Size</button>
                <input type="number" id="customLength" placeholder="Size" min="1" value="128" />
            </div>
            <!-- Toggles for sentence, enumeration, and paragraph breaks -->
            <div class="toggle-sentence-break">
                <div class="toggle-options">
                    <input type="checkbox" id="sentenceToggle" />
                    <label for="sentenceToggle">Break on full sentences</label>
                </div>
                <div class="toggle-options">
                    <input type="checkbox" id="enumerationToggle" />
                    <label for="enumerationToggle">Enumerate posts</label>
                </div>
                <div class="toggle-options">
                    <input type="checkbox" id="paragraphToggle" />
                    <label for="paragraphToggle">Break on paragraphs</label>
                </div>
            </div>
        </div>
        <!-- Results Pane -->
        <div class="lower-right-pane" id="results"></div>
    </div>
</div>

<!-- Footer -->
<footer>
    <p>
        This project is <strong>open source</strong>! View the code on
        <a href="https://github.com/MarkoPoloResearchLab/social_threader" target="_blank">GitHub</a>.
    </p>
</footer>

<script>
    /*********************************************************************
     * GLOBAL STATE
     *********************************************************************/
    let copyOrder = 0;
    let autoRechunk = false;
    let breakOnSentences = false;
    let enumerateChunks = false;
    let breakOnParagraphs = false;
    let lastChunkMethod = { type: "length", value: 280 };

    function splitIntoWordsPreservingPunctuation(textString) {
        // First, normalize spaces
        const normalizedText = textString.replace(/\s+/g, ' ').trim();
        if (!normalizedText) return [];

        const wordsArray = [];
        let currentWord = '';
        let inQuote = false;

        for (let index = 0; index < normalizedText.length; index++) {
            const character = normalizedText[index];

            if (character === ' ' && !inQuote) {
                if (currentWord) {
                    wordsArray.push(currentWord);
                    currentWord = '';
                }
                continue;
            }

            if (character === '"') {
                inQuote = !inQuote;
            }

            currentWord += character;
        }

        if (currentWord) {
            wordsArray.push(currentWord);
        }

        return wordsArray;
    }

    /*********************************************************************
     * 2) DETECT SENTENCE BOUNDARIES
     *
     * A “sentence” ends when a word’s trailing punctuation includes . ! or ?.
     * That same word *includes* that punctuation, so it’s considered
     * the last word of that sentence.
     *********************************************************************/
    function isSentenceEnd(word) {
        let strippedWord = word;
        while (strippedWord.length > 0 && '")]}'.includes(strippedWord[strippedWord.length - 1])) {
            strippedWord = strippedWord.slice(0, -1);
        }
        return /[.!?]$/.test(strippedWord);
    }

    function buildSentenceArray(wordsArray, useSentenceBreak) {
        if (!useSentenceBreak) {
            return [wordsArray.join(' ')];
        }

        const sentencesArray = [];
        let currentSentence = [];

        for (const singleWord of wordsArray) {
            currentSentence.push(singleWord);
            if (isSentenceEnd(singleWord)) {
                sentencesArray.push(currentSentence.join(' '));
                currentSentence = [];
            }
        }

        if (currentSentence.length > 0) {
            sentencesArray.push(currentSentence.join(' '));
        }

        return sentencesArray;
    }

    /*********************************************************************
     * 4) CHUNK BY LENGTH
     *
     * Takes a single string up to maximumLength. We attempt to break at
     * a “space” or punctuation boundary near maximumLength. If a single “word”
     * is bigger than maximumLength, it is forcibly chunked anyway.
     *********************************************************************/
    function chunkByLength(textString, maximumLength) {
        const resultChunks = [];
        let text = textString.replace(/\s+/g, " ").trim();
        while (text.length > 0) {
            if (text.length <= maximumLength) {
                resultChunks.push(text);
                break;
            }
            let breakIndex = -1;
            for (let index = maximumLength; index >= 0; index--) {
                if (index > text.length) continue;
                if (text.charAt(index) === " " || /[.,!?;]/.test(text.charAt(index))) {
                    breakIndex = index;
                    break;
                }
            }
            if (breakIndex > 0) {
                resultChunks.push(text.slice(0, breakIndex).trim());
                text = text.slice(breakIndex).trim();
            } else {
                resultChunks.push(text.slice(0, maximumLength));
                text = text.slice(maximumLength).trim();
            }
        }
        return resultChunks;
    }

    /*********************************************************************
     * 5) MAIN getChunks FUNCTION
     *
     *  - If breakOnParagraphs is enabled, split input by newline and process each paragraph separately.
     *  - Otherwise, split into words with all trailing punctuation attached.
     *  - Convert them to “sentences” if breakOnSentences is ON.
     *  - Each sentence might exceed maximumLength, so we sub-chunk it with chunkByLength.
     *  - Accumulate final array, then optionally enumerate.
     *********************************************************************/
    function getChunks(rawText, maximumLength, useSentenceBreak, useEnumeration, useParagraphBreak) {
        if (useParagraphBreak) {
            const paragraphsArray = rawText.split(/\r?\n+/);
            let allChunks = [];
            paragraphsArray.forEach(function(paragraph) {
                let trimmedParagraph = paragraph.trim();
                if (trimmedParagraph.length === 0) return;
                // Process paragraph without further paragraph breaking to avoid recursion
                let chunksForParagraph = getChunks(trimmedParagraph, maximumLength, useSentenceBreak, useEnumeration, false);
                allChunks.push(...chunksForParagraph);
            });
            return allChunks;
        }

        const wordsArray = splitIntoWordsPreservingPunctuation(rawText);
        if (!wordsArray.length) return [];

        const sentencesArray = buildSentenceArray(wordsArray, useSentenceBreak);
        const chunks = [];
        let currentChunk = '';

        for (const sentence of sentencesArray) {
            if (sentence.length > maximumLength) {
                if (currentChunk) {
                    chunks.push(currentChunk);
                    currentChunk = '';
                }
                const subChunks = chunkByLength(sentence, maximumLength);
                chunks.push(...subChunks);
                continue;
            }

            const potentialChunk = currentChunk
                ? currentChunk + ' ' + sentence
                : sentence;

            if (potentialChunk.length <= maximumLength) {
                currentChunk = potentialChunk;
            } else {
                if (currentChunk) chunks.push(currentChunk);
                currentChunk = sentence;
            }
        }

        if (currentChunk) {
            chunks.push(currentChunk);
        }

        return useEnumeration
            ? chunks.map((chunkText, index) => `${chunkText} (${index + 1}/${chunks.length})`)
            : chunks;
    }

    /*********************************************************************
     * DISPLAY + COPY + STATS + AUTORESIZE
     *********************************************************************/
    function displayChunks(chunks) {
        const resultsDiv = document.getElementById("results");
        resultsDiv.innerHTML = "";
        if (!chunks.length) return;

        const threadWrapper = document.createElement("div");
        threadWrapper.className = "threadWrapper";

        chunks.forEach(function(chunk) {
            const container = document.createElement("div");
            container.className = "chunkContainer";

            const textArea = document.createElement("textarea");
            textArea.readOnly = true;
            textArea.value = chunk;

            const resizeObserver = new ResizeObserver(function() {
                autoExpandTextarea(textArea);
            });
            resizeObserver.observe(textArea);

            const stats = calculateStats(chunk);
            const statsDiv = document.createElement("div");
            statsDiv.className = "stats";
            statsDiv.textContent = `Characters: ${stats.characters} | Words: ${stats.words} | Sentences: ${stats.sentences}`;

            const copyButton = document.createElement("button");
            copyButton.className = "copyButton";
            copyButton.textContent = "Copy";
            copyButton.addEventListener("click", function() {
                handleCopy(container, textArea.value, copyButton);
            });

            const infoRow = document.createElement("div");
            infoRow.className = "chunkInfo";
            infoRow.append(statsDiv, copyButton);

            container.append(textArea, infoRow);
            threadWrapper.appendChild(container);

            // Initial size adjustment
            autoExpandTextarea(textArea);
        });

        resultsDiv.appendChild(threadWrapper);
    }

    function handleCopy(container, text, copyButtonElement) {
        navigator.clipboard.writeText(text).then(function() {
            copyButtonElement.textContent = "Copied!";
            copyButtonElement.classList.add("success");
            copyButtonElement.disabled = true;
            copyOrder++;
            container.setAttribute("data-copied-order", copyOrder);
            container.classList.add("copied");

            setTimeout(function() {
                copyButtonElement.textContent = "Copy";
                copyButtonElement.classList.remove("success");
                copyButtonElement.disabled = false;
            }, 2000);
        }).catch(console.error);
    }

    function autoExpandTextarea(textAreaElement) {
        textAreaElement.style.height = "auto";
        textAreaElement.style.height = (textAreaElement.scrollHeight + 2) + 'px';
    }

    function calculateStats(chunkText) {
        return {
            characters: chunkText.length,
            words: (chunkText.match(/\b\w+\b/g) || []).length,
            sentences: (chunkText.match(/[.!?]+(\s|$)/g) || []).length,
        };
    }

    /*********************************************************************
     * WORKFLOW
     *********************************************************************/
    function doChunk(maximumLength) {
        const sourceText = document.getElementById("sourceText").value;
        const resultsDiv = document.getElementById("results");
        const inputError = document.getElementById("inputError");

        resultsDiv.innerHTML = "";
        inputError.innerHTML = "";
        copyOrder = 0;
        autoRechunk = true;

        lastChunkMethod = breakOnSentences
            ? { type: "sentence", value: maximumLength }
            : { type: "length", value: maximumLength };

        if (!sourceText.trim()) {
            inputError.textContent = "Please enter some text to split.";
            return;
        }

        const finalChunks = getChunks(sourceText, maximumLength, breakOnSentences, enumerateChunks, breakOnParagraphs);
        displayChunks(finalChunks);
    }

    function reChunkWithLastMethod() {
        if (!autoRechunk) return;
        const sourceText = document.getElementById("sourceText").value;
        if (!sourceText.trim()) {
            document.getElementById("results").innerHTML = "";
            return;
        }
        const { value } = lastChunkMethod;
        doChunk(value);
    }

    function updateInputStats() {
        const sourceTextContent = document.getElementById("sourceText").value;
        const stats = calculateStats(sourceTextContent);
        document.getElementById("inputStats").textContent =
            `Characters: ${stats.characters} | Words: ${stats.words} | Sentences: ${stats.sentences}`;
        adjustFontSize();

        // Debounce the rechunking to prevent too frequent updates
        if (window.rechunkTimeout) {
            clearTimeout(window.rechunkTimeout);
        }
        window.rechunkTimeout = setTimeout(function() {
            reChunkWithLastMethod();
        }, 100);
    }

    function adjustFontSize() {
        const sourceTextElement = document.getElementById("sourceText");
        const textLength = sourceTextElement.value.length;
        const minimumFontSize = 14;
        const maximumFontSize = 24;
        const incrementValue = 0.05;
        let newFontSize = minimumFontSize + textLength * incrementValue;
        if (newFontSize > maximumFontSize) newFontSize = maximumFontSize;
        sourceTextElement.style.fontSize = newFontSize + "px";
    }

    function updateCustomButtonLabel() {
        const inputValue = parseInt(document.getElementById("customLength").value, 10);
        const customButtonElement = document.getElementById("customButton");
        if (!isNaN(inputValue) && inputValue > 0) {
            customButtonElement.textContent = `Break with Custom (${inputValue})`;
        } else {
            customButtonElement.textContent = "Break with Custom Size";
        }
    }

    // Initialize
    document.addEventListener("DOMContentLoaded", function() {
        // Set default custom length to 128 and update label
        document.getElementById("customLength").value = 128;
        updateCustomButtonLabel();

        document.querySelectorAll(".button-group button[data-length]").forEach(function(buttonElement) {
            buttonElement.addEventListener("click", function(event) {
                document.querySelectorAll('.button-group button, #customButton').forEach(function(el) {
                    el.classList.remove('active');
                });
                event.target.classList.add('active');
                const lengthValue = parseInt(event.target.getAttribute("data-length"), 10);
                doChunk(lengthValue);
            });
        });

        document.getElementById("customButton").addEventListener("click", function() {
            const customLengthValue = parseInt(document.getElementById("customLength").value, 10);
            if (!isNaN(customLengthValue) && customLengthValue > 0) {
                document.querySelectorAll('.button-group button, #customButton').forEach(function(el) {
                    el.classList.remove('active');
                });
                document.getElementById("customButton").classList.add('active');
                doChunk(customLengthValue);
            } else {
                document.getElementById("inputError").textContent =
                    "Please enter a valid positive number for custom size.";
            }
        });

        document.getElementById("customLength").addEventListener("input", updateCustomButtonLabel);

        document.getElementById("sentenceToggle").addEventListener("change", function(event) {
            breakOnSentences = event.target.checked;
            if (autoRechunk) reChunkWithLastMethod();
        });

        document.getElementById("enumerationToggle").addEventListener("change", function(event) {
            enumerateChunks = event.target.checked;
            if (autoRechunk) reChunkWithLastMethod();
        });

        document.getElementById("paragraphToggle").addEventListener("change", function(event) {
            breakOnParagraphs = event.target.checked;
            if (autoRechunk) reChunkWithLastMethod();
        });

        document.getElementById("sourceText").addEventListener("input", updateInputStats);
    });
</script>

<!-- Optional: Formspree for feedback -->
<script src="https://formspree.io/js/formbutton-v1.min.js" defer></script>
<script>
    window.formbutton = window.formbutton || function () {
        (formbutton.q = formbutton.q || []).push(arguments);
    };
    formbutton("create", {
        action: "https://formspree.io/f/manqedkk",
        title: "Feedback",
        fields: [
            { type: "email", label: "Email:", name: "email", required: true, placeholder: "you@example.com" },
            { type: "textarea", label: "Message:", name: "message", placeholder: "What can be improved?" },
            { type: "submit" },
        ],
        styles: {
            title: { backgroundColor: "#007BFF" },
            button: { backgroundColor: "#007BFF" },
        },
    });
</script>
</body>

</html>
