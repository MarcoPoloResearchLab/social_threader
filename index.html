<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description"
    content="Threader lets you break long text into bite-sized threads for social media. Perfect for splitting text into manageable chunks for Threads, Bluesky, X, or any short-form platform." />
  <meta name="keywords"
    content="text chunker, thread splitter, social media text, sentence chunking, Twitter threads, Bluesky posts, content tool, copywriting tool" />
  <title>Social Threader</title>

  <style>
    /* 1) Global reset & layout for sticky footer */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* Make the page occupy at least 100% of viewport height, 
         arrange it as a column: content + footer at bottom */
    html,
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      font-family: Arial, sans-serif;
      background-color: #fff;
      color: #000;
    }

    /* Let .container grow to take all remaining space above footer */
    .container {
      flex: 1;
      display: flex;
      width: 100%;
    }

    /* 2) Utility Classes */
    .mb-20 {
      margin-bottom: 20px;
    }

    /* 3) Left and Right Pane Layout */
    .left-pane {
      flex: 2;
      padding: 20px;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
    }

    .right-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
    }

    /* 4) Left Pane */
    .left-pane h2 {
      margin-bottom: 10px;
    }

    .left-pane textarea {
      flex: 1;
      width: 100%;
      padding: 10px;
      font-size: 14px;
      resize: none;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #f9f9f9;
      color: #212529;
      transition: font-size 0.2s ease;
    }

    .left-pane .inputStats {
      margin-top: 10px;
      font-size: 12px;
      color: #555;
    }

    .left-pane .error {
      color: red;
      font-size: 12px;
      margin-top: 5px;
    }

    /* 5) Right Pane & Controls */
    .upper-right-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
    }

    .button-group,
    .custom-control {
      width: 90%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    button {
      background-color: #007bff;
      color: #fff;
      padding: 10px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      height: 40px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #0056b3;
    }

    .button-group button {
      width: 100%;
    }

    .custom-control {
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
    }

    .custom-control button {
      margin-right: 10px;
      flex: 1;
    }

    .custom-control input {
      width: 80px;
      height: 40px;
      font-size: 14px;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      text-align: center;
    }

    .toggle-sentence-break {
      width: 90%;
      max-width: 600px;
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 5px;
      justify-content: space-between;
    }

    .toggle-sentence-break .toggle-options {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .toggle-sentence-break label {
      font-size: 14px;
      user-select: none;
    }

    /* 6) Output Pane */
    .lower-right-pane {
      flex: 4;
      overflow-y: auto;
      padding-top: 10px;
      position: relative;
    }

    .threadWrapper {
      position: relative;
      margin-bottom: 20px;
    }

    .threadWrapper::before {
      content: "";
      position: absolute;
      top: 0;
      left: 20px;
      width: 2px;
      height: 100%;
      background-color: #ccc;
    }

    .chunkContainer {
      position: relative;
      display: flex;
      flex-direction: column;
      margin-bottom: 40px;
      padding-left: 40px;
    }

    .chunkContainer::before {
      content: "";
      position: absolute;
      top: 0;
      left: 11px;
      width: 18px;
      height: 18px;
      background-color: #fff;
      border: 2px solid #007bff;
      border-radius: 50%;
      z-index: 1;
    }

    .chunkContainer textarea {
      width: 100%;
      resize: none;
      font-family: Arial, sans-serif;
      font-size: 14px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #f9f9f9;
      color: #212529;
      white-space: pre-wrap;
      word-wrap: break-word;
      min-height: 40px;
      overflow-y: hidden;
    }

    .chunkInfo {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }

    .chunkInfo .stats {
      font-size: 12px;
      color: #555;
    }

    .copyButton {
      background-color: #28a745;
    }

    .copyButton:hover {
      background-color: #218838;
    }

    .copyButton.success {
      background-color: #28a745;
      cursor: default;
    }

    .chunkContainer.copied::before {
      content: attr(data-copied-order);
      background-color: #28a745;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
    }

    /* 7) Responsive Layout */
    @media (max-width: 800px) {
      .container {
        flex-direction: column;
      }

      .left-pane {
        border-right: none;
        border-bottom: 1px solid #ccc;
        padding-bottom: 20px;
        order: 0;
      }

      .right-pane {
        width: 100%;
        height: auto;
      }

      .upper-right-pane {
        order: 1;
        width: 100%;
      }

      .lower-right-pane {
        order: 2;
        width: 100%;
        overflow-y: auto;
      }

      .threadWrapper::before {
        left: 15px;
      }

      .chunkContainer {
        padding-left: 35px;
      }

      .chunkContainer::before {
        left: 6px;
      }
    }

    /* 8) Footer Styling */
    footer {
      text-align: center;
      padding: 20px;
      border-top: 1px solid #ccc;
    }
  </style>
</head>

<body>
  <!-- Container: stretches to fill space above footer -->
  <div class="container">
    <!-- Left pane -->
    <div class="left-pane">
      <h2>Social Threader</h2>
      <p class="mb-20">
        With Social Threader, you can split your text into smaller chunks
        ideal for Twitter/X, Bluesky, Threads, Mastodon, or any platform that
        limits character count.
      </p>
      <p class="mb-20">
        Easily create threads, track word counts, and copy each chunk with a
        single click.
      </p>
      <textarea id="sourceText" spellcheck="true" placeholder="Enter text here..." rows="10"></textarea>
      <div id="inputStats" class="inputStats"></div>
      <div id="inputError" class="error"></div>
    </div>

    <!-- Right pane -->
    <div class="right-pane">
      <div class="upper-right-pane">
        <!-- Preset chunk sizes -->
        <div class="button-group">
          <button data-length="500">Break into Threads/Mastodon (500)</button>
          <button data-length="300">Break into Bluesky (300)</button>
          <button data-length="280">Break into Twitter/X (280)</button>
        </div>

        <!-- Custom chunk size -->
        <div class="custom-control">
          <button id="customButton">Break with Custom Size</button>
          <input type="number" id="customLength" placeholder="Size" min="1" />
        </div>

        <!-- Sentence break + enumeration toggles -->
        <div class="toggle-sentence-break">
          <div class="toggle-options">
            <input type="checkbox" id="sentenceToggle" />
            <label for="sentenceToggle">Break on full sentences</label>
          </div>
          <div class="toggle-options">
            <input type="checkbox" id="enumerationToggle" />
            <label for="enumerationToggle">Enumerate posts</label>
          </div>
        </div>
      </div>
      <!-- Results go here -->
      <div class="lower-right-pane" id="results"></div>
    </div>
  </div>

  <!-- Footer: always at bottom thanks to flexbox layout -->
  <footer>
    <p>
      This project is <strong>open source</strong>! View the code on
      <a href="https://github.com/MarkoPoloResearchLab/social_threader" target="_blank">GitHub</a>.
    </p>
  </footer>

  <script>
    let copyOrder = 0;
    let autoRechunk = false;
    let breakOnSentences = false;
    let lastChunkMethod = { type: "length", value: 280 };
    let enumerateChunks = false;

    function autoExpandTextarea(textarea) {
      textarea.style.height = "auto";
      textarea.style.height = textarea.scrollHeight + "px";
    }

    function splitTextByLength(rawText, maxLen) {
      const text = rawText.replace(/\s+/g, " ").trim();
      const chunks = [];
      let startIndex = 0;
      const textLength = text.length;
      const buffer = 20;

      while (startIndex < textLength) {
        if (startIndex + maxLen >= textLength) {
          chunks.push(text.substring(startIndex).trim());
          break;
        }
        const slice = text.substring(startIndex, startIndex + maxLen + buffer);
        const lowerBound = Math.max(maxLen - buffer, 0);

        let boundary = -1;
        for (let i = lowerBound; i < maxLen && i < slice.length; i++) {
          if (
            (slice[i] === "." || slice[i] === "!" || slice[i] === "?") &&
            (i + 1 === slice.length || slice[i + 1] === " ")
          ) {
            boundary = i + 1;
          }
        }

        let breakIndex;
        if (boundary !== -1) {
          breakIndex = boundary;
        } else {
          const wordBoundary = slice.lastIndexOf(" ", maxLen);
          if (wordBoundary !== -1 && wordBoundary >= maxLen * 0.7) {
            breakIndex = wordBoundary;
          } else {
            breakIndex = maxLen;
          }
        }
        chunks.push(
          text.substring(startIndex, startIndex + breakIndex).trim()
        );
        startIndex += breakIndex;
      }

      return chunks;
    }

    function splitTextBySentencesWithMaxLen(rawText, maxLen) {
      const text = rawText.trim();
      const rawSentences = text.match(/[^.!?]+[.!?]+(\s|$)?|[^.!?]+$/g) || [];
      const allChunks = [];
      let currentChunk = "";

      for (let sentence of rawSentences) {
        sentence = sentence.trim();
        if (!sentence) continue;

        if (sentence.length > maxLen) {
          // If the sentence is too large, chunk it by length
          if (currentChunk) {
            allChunks.push(currentChunk.trim());
            currentChunk = "";
          }
          const parts = splitTextByLength(sentence, maxLen);
          for (const part of parts) {
            if (
              currentChunk &&
              currentChunk.length + 1 + part.length > maxLen
            ) {
              allChunks.push(currentChunk.trim());
              currentChunk = "";
            }
            currentChunk = currentChunk ? currentChunk + " " + part : part;
            if (currentChunk.length >= maxLen) {
              allChunks.push(currentChunk.trim());
              currentChunk = "";
            }
          }
        } else {
          // Append sentence to current chunk if it fits, otherwise start a new chunk
          if (!currentChunk) {
            currentChunk = sentence;
          } else if (currentChunk.length + 1 + sentence.length <= maxLen) {
            currentChunk += " " + sentence;
          } else {
            allChunks.push(currentChunk.trim());
            currentChunk = sentence;
          }
        }
      }

      if (currentChunk) allChunks.push(currentChunk.trim());
      return allChunks;
    }

    function getChunksWithoutFraction(txt, maxLen) {
      return breakOnSentences
        ? splitTextBySentencesWithMaxLen(txt, maxLen)
        : splitTextByLength(txt, maxLen);
    }

    // Once we have raw chunks, re-check how many chunks we have, 
    // then subtract fraction length from maxLen if enumeration is on.
    function finalizeChunksWithFraction(txt, maxLen, rawChunks) {
      let totalChunks = rawChunks.length;
      let finalChunks = rawChunks;

      while (true) {
        const fractionLen = calcFractionLen(totalChunks);
        const newMax = maxLen - fractionLen;
        if (newMax < 1) {
          return ["[Cannot fit fraction within this max length]"];
        }

        const newChunks = breakOnSentences
          ? splitTextBySentencesWithMaxLen(txt, newMax)
          : splitTextByLength(txt, newMax);

        if (newChunks.length === totalChunks) {
          finalChunks = newChunks;
          break;
        } else {
          totalChunks = newChunks.length;
          finalChunks = newChunks;
        }
      }

      return finalChunks.map((chunk, idx) => {
        const i = idx + 1;
        const fraction = ` (${i}/${totalChunks})`;
        return chunk + fraction;
      });
    }

    function calcFractionLen(total) {
      const digits = String(total).length;
      // " (" + i + "/" + total + ")" => 3 + 2 * digits
      return 3 + 2 * digits;
    }

    function doChunk(maxLen) {
      const sourceText = document.getElementById("sourceText").value;
      const resultsDiv = document.getElementById("results");
      const inputError = document.getElementById("inputError");

      resultsDiv.innerHTML = "";
      inputError.innerHTML = "";
      copyOrder = 0;
      autoRechunk = true;

      lastChunkMethod = breakOnSentences
        ? { type: "sentenceHybrid", value: maxLen }
        : { type: "length", value: maxLen };

      if (!sourceText.trim()) {
        inputError.textContent = "Please enter some text to split.";
        return;
      }

      const baseChunks = getChunksWithoutFraction(sourceText, maxLen);
      let finalChunks;
      if (!enumerateChunks) {
        finalChunks = baseChunks;
      } else {
        finalChunks = finalizeChunksWithFraction(
          sourceText,
          maxLen,
          baseChunks
        );
      }

      displayChunks(finalChunks);
    }

    function displayChunks(chunks) {
      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = "";
      if (!chunks.length) return;

      const threadWrapper = document.createElement("div");
      threadWrapper.className = "threadWrapper";

      chunks.forEach((chunk) => {
        const container = document.createElement("div");
        container.className = "chunkContainer";

        const textArea = document.createElement("textarea");
        textArea.readOnly = true;
        textArea.value = chunk;
        autoExpandTextarea(textArea);

        const stats = calculateStats(chunk);
        const statsDiv = document.createElement("div");
        statsDiv.className = "stats";
        statsDiv.textContent = `Characters: ${stats.characters} | Words: ${stats.words} | Sentences: ${stats.sentences}`;

        const copyButton = document.createElement("button");
        copyButton.className = "copyButton";
        copyButton.textContent = "Copy";
        copyButton.addEventListener("click", () =>
          handleCopy(container, textArea.value, copyButton)
        );

        const infoRow = document.createElement("div");
        infoRow.className = "chunkInfo";
        infoRow.append(statsDiv, copyButton);

        container.append(textArea, infoRow);
        threadWrapper.appendChild(container);
      });

      resultsDiv.appendChild(threadWrapper);

      // Auto-resize after DOM insertion
      new ResizeObserver(() => {
        threadWrapper.querySelectorAll("textarea").forEach(autoExpandTextarea);
      }).observe(resultsDiv);
    }

    function handleCopy(container, text, copyBtn) {
      navigator.clipboard
        .writeText(text)
        .then(() => {
          copyBtn.textContent = "Copied!";
          copyBtn.classList.add("success");
          copyBtn.disabled = true;
          copyOrder++;
          container.setAttribute("data-copied-order", copyOrder);
          container.classList.add("copied");

          setTimeout(() => {
            copyBtn.textContent = "Copy";
            copyBtn.classList.remove("success");
            copyBtn.disabled = false;
          }, 2000);
        })
        .catch(console.error);
    }

    function reChunkWithLastMethod() {
      if (!autoRechunk) return;
      const sourceText = document.getElementById("sourceText").value.trim();
      if (!sourceText) {
        document.getElementById("results").innerHTML = "";
        return;
      }
      const { value } = lastChunkMethod;
      doChunk(value);
    }

    function calculateStats(txt) {
      return {
        characters: txt.length,
        words: (txt.match(/\b\w+\b/g) || []).length,
        sentences: (txt.match(/[^.!?]+[.!?]+/g) || []).length,
      };
    }

    function updateInputStats() {
      const src = document.getElementById("sourceText").value;
      const stats = calculateStats(src);
      document.getElementById("inputStats").textContent =
        `Characters: ${stats.characters} | Words: ${stats.words} | Sentences: ${stats.sentences}`;
      adjustFontSize();
      reChunkWithLastMethod();
    }

    function adjustFontSize() {
      const textArea = document.getElementById("sourceText");
      const textLength = textArea.value.length;
      const minSize = 14;
      const maxSize = 24;
      const increment = 0.05;
      let newSize = minSize + textLength * increment;
      if (newSize > maxSize) newSize = maxSize;
      textArea.style.fontSize = newSize + "px";
    }

    function updateCustomButtonLabel() {
      const inputVal = parseInt(document.getElementById("customLength").value, 10);
      const customButton = document.getElementById("customButton");
      if (!isNaN(inputVal) && inputVal > 0) {
        customButton.textContent = `Break with Custom (${inputVal})`;
      } else {
        customButton.textContent = "Break with Custom Size";
      }
    }

    // Event listeners
    document.querySelectorAll(".button-group button[data-length]").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const len = parseInt(e.target.getAttribute("data-length"), 10);
        doChunk(len);
      });
    });

    document.getElementById("customButton").addEventListener("click", () => {
      const val = parseInt(document.getElementById("customLength").value, 10);
      if (!isNaN(val) && val > 0) {
        doChunk(val);
      } else {
        document.getElementById("inputError").textContent =
          "Please enter a valid positive number for custom size.";
      }
    });

    document.getElementById("customLength").addEventListener("input", updateCustomButtonLabel);

    document.getElementById("sentenceToggle").addEventListener("change", (evt) => {
      breakOnSentences = evt.target.checked;
      if (autoRechunk) reChunkWithLastMethod();
    });

    document.getElementById("enumerationToggle").addEventListener("change", (evt) => {
      enumerateChunks = evt.target.checked;
      if (autoRechunk) reChunkWithLastMethod();
    });

    document.getElementById("sourceText").addEventListener("input", updateInputStats);
  </script>

  <!-- Formspree "formbutton" JS -->
  <script src="https://formspree.io/js/formbutton-v1.min.js" defer></script>
  <script>
    window.formbutton =
      window.formbutton ||
      function () {
        (formbutton.q = formbutton.q || []).push(arguments);
      };

    formbutton("create", {
      action: "https://formspree.io/f/manqedkk",
      title: "Feedback",
      fields: [
        {
          type: "email",
          label: "Email:",
          name: "email",
          required: true,
          placeholder: "you@example.com",
        },
        {
          type: "textarea",
          label: "Message:",
          name: "message",
          placeholder: "What can be improved?",
        },
        { type: "submit" },
      ],
      styles: {
        title: {
          backgroundColor: "#007BFF",
        },
        button: {
          backgroundColor: "#007BFF",
        },
      },
    });
  </script>
</body>

</html>
